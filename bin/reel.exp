#!/usr/bin/env expect

### Copyright (c) 2018-2020 David Spence <david@roughsketch.co.uk>
###
### SPDX-License-Identifier: GPL-2.0-or-later

### parse command line arguments

proc parse_argv { argv } {
    set parsed [list]
    ### leading options control this script
    while { [string match {-*} [lindex $argv 0]] } {
        set opt [lindex $argv 0]
        set argv [lreplace $argv 0 0]
        switch $opt {
            -r {
                lappend parsed step_re {^[^\r]*\r}
            }
            -l {
                if { ![llength $argv] } { error "-l requires a filename" }
                lappend parsed logfile [lindex $argv 0]
                set argv [lreplace $argv 0 0]
            }
            default {
                error [format {unknown option "%s"} [lindex $argv 0]]
            }
        }
    }
    ### trailing arguments and options are spawned subprocess args
    lappend parsed argv $argv
    return $parsed
}

array set ctrl {logfile "" step_re {^[^\n]*\n}}
array set ctrl [parse_argv $argv]

### decode step

package require json

proc step_decode { str } {
    set CTRL_D [format %c 4]
    array set step {timeout -1}
    foreach {key val} [json::json2dict $str] {
        switch $key {
            expect {
                for { set idx 0 } { $idx < [llength $val] } { incr idx } {
                    set exp [lindex $val $idx]
                    if { $CTRL_D != $exp } {
                        lappend step(expect) -re "^.*($exp)" [list matched $idx $exp]
                    } elseif { ![info exists step(expect)] } {
                        array set step {expect {}}
                    }
                }
            }
            execute -
            timeout -
            default { array set step [list $key $val] }
        }
    }
    if { [info exists step(expect)] } {
        lappend step(expect) timeout {event "timeout"} eof {event "eof"}
    }
    return [array get step]
}

### expect events

package require json::write
::json::write indented 0
::json::write aligned 0

proc matched { idx pattern } {
    set str $::expect_out(0,string)
    set match $::expect_out(1,string)
    set before [string range $str 0 [expr {[string length $str] - [string length $match] - 1}]]
    lappend obj event [json::write string "match"]
    lappend obj idx $idx
    lappend obj pattern [json::write string $pattern]
    lappend obj before [json::write string $before]
    lappend obj match [json::write string $match]
    return [eval json::write object $obj]
}
proc event { event } {
    lappend obj event [json::write string $event]
    return [eval json::write object $obj]
}

### perform reel

log_user 0
catch [list log_file -noappend -a $ctrl(logfile)]

set pid [eval spawn -noecho $ctrl(argv)]

while 1 {
    # read
    array set step [expect_user -re $ctrl(step_re) {step_decode $expect_out(0,string)} eof break]
    # ?execute?
    if { [info exists step(execute)] } { send "$step(execute)\r" }
    # ?expect?
    if { [info exists step(expect)] } { send_user "[eval expect -timeout $step(timeout) $step(expect)]\r\n" }
    # loop
    array unset step
}

catch [list close]
set result [wait $pid]
exit [expr {[lindex $result 2] == 0 ? [lindex $result 3] : 42}]
